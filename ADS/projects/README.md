# Project——LSMKV

这是上海交通大学“高级数据结构”课程的 LSMKV 项目，主要实现了一种基于 LSM 树结构以及键值分离技术的持久化存储结构，支持 PUT DELETE GET SCAN RESET 等基本操作，适用于需要高性能读写的情景。

更多关于本项目的背景和实现请参阅 doc 文件夹中的文档。

code 文件夹下的文件结构（不全）：

```text
.
├── Makefile  // 使用GNU编译
├── correctness.cc // 正确性测试
├── data      // SSTable和vLog文件存储路径
├── kvstore.cc     // LSMKV结构主文件
├── kvstore.h
├── kvstore_api.h
├── persistence.cc // 持久性测试
├── utils.h         // 工具函数库
├── MurmurHash3.h  // 项目中BF用到的哈希函数库
└── test.h         // 测试类
......
```

## 进行编译

项目可以使用 linux 环境下的 GNU 进行编译。确保你已经安装了环境所需的工具。

输入

```
$ make all
```

编译正确性测试(correctness)、持久性测试(persistence)与性能测试(test)程序。

输入

```
$ make clean
```

以删除所有生成的结果。

## 运行测试

在确保项目已经成功编译的前提下，输入

```
$ ./test
```

运行性能测试程序，程序将运行四部分的测试（内容详见报告文档），并把测试结果输入到 test_result.txt 文件中。

输入

```
$ ./correctness
```

运行正确性测试，测试分为三部分（基本测试、复杂测试、垃圾回收测试），带上参数-v 以获取测试结果的错误信息。

输入

```
$ ./persistence
```

运行持久性测试，测试内容主要是模拟意外中断程序后检查键值存储的正确性。

## 获取实验数据结果

实验数据会输出到 test_result.txt 文件中，随后可以使用 figure.py 程序对于数据进行图像的绘制。

## 参数修改

本项目支持灵活调整参数，包括 sst 文件大小限制、BF 大小、缓存策略等，详见 config.h 文件。

## 一些细节

- 项目对于 compaction 功能的实现没有使用文档推荐的归并排序，而是使用了 stl 的 map 结构（红黑树），并且基于“sst 文件处于的层数越大，时间戳越旧”的基本事实，对于缓存中每一层的 sst 文件进行基于时间戳的升序排序，从而实现对于重复的键值对无需判断时间戳，只需不断覆盖即可。

- 同理，GET 操作对于 sst 缓存的查询也是基于上述技巧，做到了查找到的第一个键值对就是最新的键值对，大大减少了扫描的开销。

- 若有对代码实现有疑问，代码中的注释非常全，基本上每一处都写明了为什么这么写，可供参考。

## 贡献者

- 朱涵 SJTU SE2022
