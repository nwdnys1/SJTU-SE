<!-- 起始时间17:23 -->
# HW10 Thread Safety
## 死锁、活锁
- 死锁：由于线程等待锁的冲突链成环，导致没有一个线程能进展的情况。

  举例：线程1先持A锁再持B锁，线程2先持B锁再持A锁。因为某种调度导致两线程都先获得了第1把锁，分别获取第2把锁的时候被对方阻塞。

- 活锁：线程执行时虽然没有阻塞导致完全无法执行，但由于所有线程都主动让出自己的资源，导致实际没有一个进程能完成执行的情况。

  举例：有100个线程和100把锁，第i个线程的逻辑如下。
  ```cpp
  retry:
  for (int l = 0; l < 100; ++l)
    if (!lock[(i+k)%100].try_acquire())
    {
        for (; l >= 0; --l)
            lock[(i+k)%100].release()
        goto retry;
    }
  ```
  虽然理论上有每个线程都执行完毕的可能，但大概率所有线程会一直在拿锁、冲突、放锁的循环中无法结束。

## 并发栈
在压栈、弹栈不频繁发生的场景下，可以使用读写锁，让访问栈顶、判空的只读操作之间可以并行。

但这样实现时，压栈、弹栈等写操作之间、写与读操作之间依然无法并行。

设计不涉及死锁与活锁。
<!-- 结束时间17:39 -->